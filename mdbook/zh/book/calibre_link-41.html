<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>REST作为一种架构风格  - 实现领域驱动设计</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="calibre_link-1.html"><strong aria-hidden="true">1.</strong> 封面</a></li><li class="chapter-item expanded "><a href="calibre_link-4.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="calibre_link-6.html"><strong aria-hidden="true">3.</strong> 第1章 DDD入门 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-7.html"><strong aria-hidden="true">3.1.</strong> 我能DDD吗？ </a></li><li class="chapter-item expanded "><a href="calibre_link-8.html"><strong aria-hidden="true">3.2.</strong> 为什么我们需要DDD </a></li><li class="chapter-item expanded "><a href="calibre_link-9.html"><strong aria-hidden="true">3.3.</strong> 如何DDD </a></li><li class="chapter-item expanded "><a href="calibre_link-10.html"><strong aria-hidden="true">3.4.</strong> 使用DDD的业务价值 </a></li><li class="chapter-item expanded "><a href="calibre_link-13.html"><strong aria-hidden="true">3.5.</strong> 实施DDD所面临的挑战</a></li><li class="chapter-item expanded "><a href="calibre_link-14.html"><strong aria-hidden="true">3.6.</strong> 虚构的案例，真实的实践 </a></li><li class="chapter-item expanded "><a href="calibre_link-15.html"><strong aria-hidden="true">3.7.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-16.html"><strong aria-hidden="true">4.</strong> 第2章 领域、子域和限界上下文 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-16.html"><strong aria-hidden="true">4.1.</strong> 总览 </a></li><li class="chapter-item expanded "><a href="calibre_link-17.html"><strong aria-hidden="true">4.2.</strong> 工作中的子域和限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-18.html"><strong aria-hidden="true">4.3.</strong> 将关注点放在核心域上 </a></li><li class="chapter-item expanded "><a href="calibre_link-19.html"><strong aria-hidden="true">4.4.</strong> 战略设计为什么重要 </a></li><li class="chapter-item expanded "><a href="calibre_link-20.html"><strong aria-hidden="true">4.5.</strong> 现实世界中领域和子域 </a></li><li class="chapter-item expanded "><a href="calibre_link-21.html"><strong aria-hidden="true">4.6.</strong> 理解限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-22.html"><strong aria-hidden="true">4.7.</strong> 限界上下文不仅仅只包含模型 </a></li><li class="chapter-item expanded "><a href="calibre_link-23.html"><strong aria-hidden="true">4.8.</strong> 限界上下文的大小 </a></li><li class="chapter-item expanded "><a href="calibre_link-24.html"><strong aria-hidden="true">4.9.</strong> 与技术组件保持一致 </a></li><li class="chapter-item expanded "><a href="calibre_link-25.html"><strong aria-hidden="true">4.10.</strong> 示例上下文</a></li><li class="chapter-item expanded "><a href="calibre_link-26.html"><strong aria-hidden="true">4.11.</strong> 协作上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-27.html"><strong aria-hidden="true">4.12.</strong> 身份与访问上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-28.html"><strong aria-hidden="true">4.13.</strong> 敏捷项目管理上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-29.html"><strong aria-hidden="true">4.14.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-30.html"><strong aria-hidden="true">5.</strong> 第3章 上下文映射图 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-30.html"><strong aria-hidden="true">5.1.</strong> 上下文映射图为什么重要 </a></li><li class="chapter-item expanded "><a href="calibre_link-31.html"><strong aria-hidden="true">5.2.</strong> 绘制上下文映射图 </a></li><li class="chapter-item expanded "><a href="calibre_link-32.html"><strong aria-hidden="true">5.3.</strong> 产品和组织关系 </a></li><li class="chapter-item expanded "><a href="calibre_link-33.html"><strong aria-hidden="true">5.4.</strong> 映射3个示例限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-34.html"><strong aria-hidden="true">5.5.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-35.html"><strong aria-hidden="true">6.</strong> 第4章 架构 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-36.html"><strong aria-hidden="true">6.1.</strong> 采访一个成功的CIO</a></li><li class="chapter-item expanded "><a href="calibre_link-37.html"><strong aria-hidden="true">6.2.</strong> 分层 </a></li><li class="chapter-item expanded "><a href="calibre_link-38.html"><strong aria-hidden="true">6.3.</strong> 依赖倒置原则 </a></li><li class="chapter-item expanded "><a href="calibre_link-39.html"><strong aria-hidden="true">6.4.</strong> 六边形架构（端口与适配器） </a></li><li class="chapter-item expanded "><a href="calibre_link-40.html"><strong aria-hidden="true">6.5.</strong> 面向服务架构 </a></li><li class="chapter-item expanded "><a href="calibre_link-41.html" class="active"><strong aria-hidden="true">6.6.</strong> REST </a></li><li class="chapter-item expanded "><a href="calibre_link-41.html" class="active"><strong aria-hidden="true">6.7.</strong> REST作为一种架构风格 </a></li><li class="chapter-item expanded "><a href="calibre_link-42.html"><strong aria-hidden="true">6.8.</strong> RESTful HTTP服务器的关键方面 </a></li><li class="chapter-item expanded "><a href="calibre_link-43.html"><strong aria-hidden="true">6.9.</strong> RESTful HTTP客户端的关键方面 </a></li><li class="chapter-item expanded "><a href="calibre_link-44.html"><strong aria-hidden="true">6.10.</strong> REST和DDD </a></li><li class="chapter-item expanded "><a href="calibre_link-45.html"><strong aria-hidden="true">6.11.</strong> 为什么是REST？ </a></li><li class="chapter-item expanded "><a href="calibre_link-45.html"><strong aria-hidden="true">6.12.</strong> 命令和查询职责分离——CQRS</a></li><li class="chapter-item expanded "><a href="calibre_link-46.html"><strong aria-hidden="true">6.13.</strong> CQRS的各个方面 </a></li><li class="chapter-item expanded "><a href="calibre_link-47.html"><strong aria-hidden="true">6.14.</strong> 处理具有最终一致性的查询模型 </a></li><li class="chapter-item expanded "><a href="calibre_link-48.html"><strong aria-hidden="true">6.15.</strong> 事件驱动架构 </a></li><li class="chapter-item expanded "><a href="calibre_link-49.html"><strong aria-hidden="true">6.16.</strong> 管道和过滤器 </a></li><li class="chapter-item expanded "><a href="calibre_link-50.html"><strong aria-hidden="true">6.17.</strong> 长时处理过程（也叫Saga） </a></li><li class="chapter-item expanded "><a href="calibre_link-51.html"><strong aria-hidden="true">6.18.</strong> 事件源 </a></li><li class="chapter-item expanded "><a href="calibre_link-52.html"><strong aria-hidden="true">6.19.</strong> 数据网织和基于网格的分布式计算 </a></li><li class="chapter-item expanded "><a href="calibre_link-53.html"><strong aria-hidden="true">6.20.</strong> 数据复制 </a></li><li class="chapter-item expanded "><a href="calibre_link-54.html"><strong aria-hidden="true">6.21.</strong> 事件驱动网织和领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-54.html"><strong aria-hidden="true">6.22.</strong> 持续查询 </a></li><li class="chapter-item expanded "><a href="calibre_link-55.html"><strong aria-hidden="true">6.23.</strong> 分布式处理 </a></li><li class="chapter-item expanded "><a href="calibre_link-56.html"><strong aria-hidden="true">6.24.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-57.html"><strong aria-hidden="true">7.</strong> 第5章 实体 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-57.html"><strong aria-hidden="true">7.1.</strong> 为什么使用实体 </a></li><li class="chapter-item expanded "><a href="calibre_link-58.html"><strong aria-hidden="true">7.2.</strong> 唯一标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-59.html"><strong aria-hidden="true">7.3.</strong> 用户提供唯一标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-60.html"><strong aria-hidden="true">7.4.</strong> 应用程序生成唯一标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-61.html"><strong aria-hidden="true">7.5.</strong> 持久化机制生成唯一标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-62.html"><strong aria-hidden="true">7.6.</strong> 另一个限界上下文提供唯一标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-63.html"><strong aria-hidden="true">7.7.</strong> 标识生成时间 </a></li><li class="chapter-item expanded "><a href="calibre_link-64.html"><strong aria-hidden="true">7.8.</strong> 委派标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-65.html"><strong aria-hidden="true">7.9.</strong> 标识稳定性 </a></li><li class="chapter-item expanded "><a href="calibre_link-66.html"><strong aria-hidden="true">7.10.</strong> 发现实体及其本质特征 </a></li><li class="chapter-item expanded "><a href="calibre_link-67.html"><strong aria-hidden="true">7.11.</strong> 揭开实体及其本质特征的神秘面纱 </a></li><li class="chapter-item expanded "><a href="calibre_link-68.html"><strong aria-hidden="true">7.12.</strong> 挖掘实体的关键行为 </a></li><li class="chapter-item expanded "><a href="calibre_link-69.html"><strong aria-hidden="true">7.13.</strong> 角色和职责 </a></li><li class="chapter-item expanded "><a href="calibre_link-70.html"><strong aria-hidden="true">7.14.</strong> 创建实体 </a></li><li class="chapter-item expanded "><a href="calibre_link-71.html"><strong aria-hidden="true">7.15.</strong> 验证 </a></li><li class="chapter-item expanded "><a href="calibre_link-72.html"><strong aria-hidden="true">7.16.</strong> 跟踪变化 </a></li><li class="chapter-item expanded "><a href="calibre_link-72.html"><strong aria-hidden="true">7.17.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-73.html"><strong aria-hidden="true">8.</strong> 第6章 值对象 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-74.html"><strong aria-hidden="true">8.1.</strong> 值对象的特征 </a></li><li class="chapter-item expanded "><a href="calibre_link-75.html"><strong aria-hidden="true">8.2.</strong> 度量或描述 </a></li><li class="chapter-item expanded "><a href="calibre_link-75.html"><strong aria-hidden="true">8.3.</strong> 不变性 </a></li><li class="chapter-item expanded "><a href="calibre_link-76.html"><strong aria-hidden="true">8.4.</strong> 概念整体 </a></li><li class="chapter-item expanded "><a href="calibre_link-77.html"><strong aria-hidden="true">8.5.</strong> 可替换性 </a></li><li class="chapter-item expanded "><a href="calibre_link-78.html"><strong aria-hidden="true">8.6.</strong> 值对象相等性 </a></li><li class="chapter-item expanded "><a href="calibre_link-79.html"><strong aria-hidden="true">8.7.</strong> 无副作用行为 </a></li><li class="chapter-item expanded "><a href="calibre_link-80.html"><strong aria-hidden="true">8.8.</strong> 最小化集成 </a></li><li class="chapter-item expanded "><a href="calibre_link-81.html"><strong aria-hidden="true">8.9.</strong> 用值对象表示标准类型 </a></li><li class="chapter-item expanded "><a href="calibre_link-82.html"><strong aria-hidden="true">8.10.</strong> 测试值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-83.html"><strong aria-hidden="true">8.11.</strong> 实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-84.html"><strong aria-hidden="true">8.12.</strong> 持久化值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-85.html"><strong aria-hidden="true">8.13.</strong> 拒绝由数据建模泄漏带来的不利影响 </a></li><li class="chapter-item expanded "><a href="calibre_link-86.html"><strong aria-hidden="true">8.14.</strong> ORM与单个值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-87.html"><strong aria-hidden="true">8.15.</strong> 多个值对象序列化到单个列中 </a></li><li class="chapter-item expanded "><a href="calibre_link-88.html"><strong aria-hidden="true">8.16.</strong> 使用数据库实体保存多个值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-89.html"><strong aria-hidden="true">8.17.</strong> 使用联合表保存多个值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-90.html"><strong aria-hidden="true">8.18.</strong> ORM与枚举状态对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-91.html"><strong aria-hidden="true">8.19.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-92.html"><strong aria-hidden="true">9.</strong> 第7章 领域服务 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-93.html"><strong aria-hidden="true">9.1.</strong> 什么是领域服务（首先，什么不是领域服务） </a></li><li class="chapter-item expanded "><a href="calibre_link-94.html"><strong aria-hidden="true">9.2.</strong> 请确定你是否需要一个领域服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-95.html"><strong aria-hidden="true">9.3.</strong> 建模领域服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-96.html"><strong aria-hidden="true">9.4.</strong> 独立接口有必要吗 </a></li><li class="chapter-item expanded "><a href="calibre_link-1.html"><strong aria-hidden="true">9.5.</strong> 一个计算过程 </a></li><li class="chapter-item expanded "><a href="calibre_link-97.html"><strong aria-hidden="true">9.6.</strong> 转换服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-98.html"><strong aria-hidden="true">9.7.</strong> 为领域服务创建一个迷你层 </a></li><li class="chapter-item expanded "><a href="calibre_link-98.html"><strong aria-hidden="true">9.8.</strong> 测试领域服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-99.html"><strong aria-hidden="true">9.9.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-100.html"><strong aria-hidden="true">10.</strong> 第8章 领域事件 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-100.html"><strong aria-hidden="true">10.1.</strong> 何时/为什么使用领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-101.html"><strong aria-hidden="true">10.2.</strong> 建模领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-102.html"><strong aria-hidden="true">10.3.</strong> 创建具有聚合特征的领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-103.html"><strong aria-hidden="true">10.4.</strong> 身份标识 </a></li><li class="chapter-item expanded "><a href="calibre_link-104.html"><strong aria-hidden="true">10.5.</strong> 从领域模型中发布领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-104.html"><strong aria-hidden="true">10.6.</strong> 发送方 </a></li><li class="chapter-item expanded "><a href="calibre_link-105.html"><strong aria-hidden="true">10.7.</strong> 订阅方 </a></li><li class="chapter-item expanded "><a href="calibre_link-106.html"><strong aria-hidden="true">10.8.</strong> 向远程限界上下文发布领域事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-106.html"><strong aria-hidden="true">10.9.</strong> 消息设施的一致性 </a></li><li class="chapter-item expanded "><a href="calibre_link-107.html"><strong aria-hidden="true">10.10.</strong> 自治服务和系统 </a></li><li class="chapter-item expanded "><a href="calibre_link-108.html"><strong aria-hidden="true">10.11.</strong> 容许时延 </a></li><li class="chapter-item expanded "><a href="calibre_link-109.html"><strong aria-hidden="true">10.12.</strong> 事件存储 </a></li><li class="chapter-item expanded "><a href="calibre_link-110.html"><strong aria-hidden="true">10.13.</strong> 转发存储事件的架构风格 </a></li><li class="chapter-item expanded "><a href="calibre_link-110.html"><strong aria-hidden="true">10.14.</strong> 以REST资源的方式发布事件通知 </a></li><li class="chapter-item expanded "><a href="calibre_link-111.html"><strong aria-hidden="true">10.15.</strong> 通过消息中间件发布事件通知 </a></li><li class="chapter-item expanded "><a href="calibre_link-112.html"><strong aria-hidden="true">10.16.</strong> 实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-113.html"><strong aria-hidden="true">10.17.</strong> 发布NotificationLog </a></li><li class="chapter-item expanded "><a href="calibre_link-114.html"><strong aria-hidden="true">10.18.</strong> 发布基于消息的事件通知 </a></li><li class="chapter-item expanded "><a href="calibre_link-115.html"><strong aria-hidden="true">10.19.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-116.html"><strong aria-hidden="true">11.</strong> 第9章 模块 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-116.html"><strong aria-hidden="true">11.1.</strong> 通过模块完成设计 </a></li><li class="chapter-item expanded "><a href="calibre_link-117.html"><strong aria-hidden="true">11.2.</strong> 模块的基本命名规范 </a></li><li class="chapter-item expanded "><a href="calibre_link-117.html"><strong aria-hidden="true">11.3.</strong> 领域模型的命名规范 </a></li><li class="chapter-item expanded "><a href="calibre_link-118.html"><strong aria-hidden="true">11.4.</strong> 敏捷项目管理上下文中的模块 </a></li><li class="chapter-item expanded "><a href="calibre_link-119.html"><strong aria-hidden="true">11.5.</strong> 其他层中的模块 </a></li><li class="chapter-item expanded "><a href="calibre_link-120.html"><strong aria-hidden="true">11.6.</strong> 先考虑模块，再是限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-121.html"><strong aria-hidden="true">11.7.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-122.html"><strong aria-hidden="true">12.</strong> 第10章 聚合 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-123.html"><strong aria-hidden="true">12.1.</strong> 在Scrum核心领域中使用聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-124.html"><strong aria-hidden="true">12.2.</strong> 第一次尝试：臃肿的聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-125.html"><strong aria-hidden="true">12.3.</strong> 第二次尝试：多个聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-126.html"><strong aria-hidden="true">12.4.</strong> 原则：在一致性边界之内建模真正的不变条件 </a></li><li class="chapter-item expanded "><a href="calibre_link-127.html"><strong aria-hidden="true">12.5.</strong> 原则：设计小聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-128.html"><strong aria-hidden="true">12.6.</strong> 不要相信每一个用例 </a></li><li class="chapter-item expanded "><a href="calibre_link-129.html"><strong aria-hidden="true">12.7.</strong> 原则：通过唯一标识引用其他聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-130.html"><strong aria-hidden="true">12.8.</strong> 通过标识引用使多个聚合协同工作 </a></li><li class="chapter-item expanded "><a href="calibre_link-131.html"><strong aria-hidden="true">12.9.</strong> 建模对象导航性 </a></li><li class="chapter-item expanded "><a href="calibre_link-132.html"><strong aria-hidden="true">12.10.</strong> 可伸缩性和分布式 </a></li><li class="chapter-item expanded "><a href="calibre_link-133.html"><strong aria-hidden="true">12.11.</strong> 原则：在边界之外使用最终一致性 </a></li><li class="chapter-item expanded "><a href="calibre_link-134.html"><strong aria-hidden="true">12.12.</strong> 谁的任务？ </a></li><li class="chapter-item expanded "><a href="calibre_link-135.html"><strong aria-hidden="true">12.13.</strong> 打破原则的理由 </a></li><li class="chapter-item expanded "><a href="calibre_link-138.html"><strong aria-hidden="true">12.14.</strong> 遵循原则 </a></li><li class="chapter-item expanded "><a href="calibre_link-139.html"><strong aria-hidden="true">12.15.</strong> 估算聚合成本 </a></li><li class="chapter-item expanded "><a href="calibre_link-140.html"><strong aria-hidden="true">12.16.</strong> 常见用例场景 </a></li><li class="chapter-item expanded "><a href="calibre_link-141.html"><strong aria-hidden="true">12.17.</strong> 内存消耗 </a></li><li class="chapter-item expanded "><a href="calibre_link-142.html"><strong aria-hidden="true">12.18.</strong> 探索另外的设计 </a></li><li class="chapter-item expanded "><a href="calibre_link-143.html"><strong aria-hidden="true">12.19.</strong> 实现最终一致性 </a></li><li class="chapter-item expanded "><a href="calibre_link-144.html"><strong aria-hidden="true">12.20.</strong> 这是Scrum团队成员的任务吗？ </a></li><li class="chapter-item expanded "><a href="calibre_link-145.html"><strong aria-hidden="true">12.21.</strong> 决定的时候到了 </a></li><li class="chapter-item expanded "><a href="calibre_link-146.html"><strong aria-hidden="true">12.22.</strong> 创建具有唯一标识的根实体</a></li><li class="chapter-item expanded "><a href="calibre_link-147.html"><strong aria-hidden="true">12.23.</strong> 优先使用值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-148.html"><strong aria-hidden="true">12.24.</strong> 使用迪米特法则和“告诉而非询问”原则 </a></li><li class="chapter-item expanded "><a href="calibre_link-149.html"><strong aria-hidden="true">12.25.</strong> 乐观并发 </a></li><li class="chapter-item expanded "><a href="calibre_link-150.html"><strong aria-hidden="true">12.26.</strong> 避免依赖注入 </a></li><li class="chapter-item expanded "><a href="calibre_link-151.html"><strong aria-hidden="true">12.27.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-152.html"><strong aria-hidden="true">13.</strong> 第11章 工厂 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-152.html"><strong aria-hidden="true">13.1.</strong> 领域模型中的工厂 </a></li><li class="chapter-item expanded "><a href="calibre_link-153.html"><strong aria-hidden="true">13.2.</strong> 聚合根中的工厂方法 </a></li><li class="chapter-item expanded "><a href="calibre_link-154.html"><strong aria-hidden="true">13.3.</strong> 创建CalendarEntry实例 </a></li><li class="chapter-item expanded "><a href="calibre_link-155.html"><strong aria-hidden="true">13.4.</strong> 创建Discussion实例 </a></li><li class="chapter-item expanded "><a href="calibre_link-156.html"><strong aria-hidden="true">13.5.</strong> 领域服务中的工厂 </a></li><li class="chapter-item expanded "><a href="calibre_link-157.html"><strong aria-hidden="true">13.6.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-158.html"><strong aria-hidden="true">14.</strong> 第12章 资源库 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-159.html"><strong aria-hidden="true">14.1.</strong> 面向集合资源库 </a></li><li class="chapter-item expanded "><a href="calibre_link-160.html"><strong aria-hidden="true">14.2.</strong> Hibernate实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-161.html"><strong aria-hidden="true">14.3.</strong> TopLink实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-162.html"><strong aria-hidden="true">14.4.</strong> 面向持久化资源库 </a></li><li class="chapter-item expanded "><a href="calibre_link-163.html"><strong aria-hidden="true">14.5.</strong> Coherence实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-164.html"><strong aria-hidden="true">14.6.</strong> MongoDB实现 </a></li><li class="chapter-item expanded "><a href="calibre_link-165.html"><strong aria-hidden="true">14.7.</strong> 额外的行为 </a></li><li class="chapter-item expanded "><a href="calibre_link-166.html"><strong aria-hidden="true">14.8.</strong> 管理事务 </a></li><li class="chapter-item expanded "><a href="calibre_link-167.html"><strong aria-hidden="true">14.9.</strong> 警告 </a></li><li class="chapter-item expanded "><a href="calibre_link-167.html"><strong aria-hidden="true">14.10.</strong> 类型层级 </a></li><li class="chapter-item expanded "><a href="calibre_link-168.html"><strong aria-hidden="true">14.11.</strong> 资源库 vs 数据访问对象（DAO） </a></li><li class="chapter-item expanded "><a href="calibre_link-169.html"><strong aria-hidden="true">14.12.</strong> 测试资源库 </a></li><li class="chapter-item expanded "><a href="calibre_link-170.html"><strong aria-hidden="true">14.13.</strong> 以内存实现进行测试 </a></li><li class="chapter-item expanded "><a href="calibre_link-171.html"><strong aria-hidden="true">14.14.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-172.html"><strong aria-hidden="true">15.</strong> 第13章 集成限界上下文 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-172.html"><strong aria-hidden="true">15.1.</strong> 集成基础知识 </a></li><li class="chapter-item expanded "><a href="calibre_link-173.html"><strong aria-hidden="true">15.2.</strong> 分布式系统之间存在根本性区别 </a></li><li class="chapter-item expanded "><a href="calibre_link-173.html"><strong aria-hidden="true">15.3.</strong> 跨系统边界交换信息 </a></li><li class="chapter-item expanded "><a href="calibre_link-174.html"><strong aria-hidden="true">15.4.</strong> 通过REST资源集成限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-175.html"><strong aria-hidden="true">15.5.</strong> 实现REST资源 </a></li><li class="chapter-item expanded "><a href="calibre_link-176.html"><strong aria-hidden="true">15.6.</strong> 使用防腐层实现REST客户端 </a></li><li class="chapter-item expanded "><a href="calibre_link-177.html"><strong aria-hidden="true">15.7.</strong> 通过消息集成限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-177.html"><strong aria-hidden="true">15.8.</strong> 从Scrum的产品负责人和团队成员处得到持续通知 </a></li><li class="chapter-item expanded "><a href="calibre_link-178.html"><strong aria-hidden="true">15.9.</strong> 你能处理这样的职责吗？ </a></li><li class="chapter-item expanded "><a href="calibre_link-179.html"><strong aria-hidden="true">15.10.</strong> 长时处理过程，以及避免职责 </a></li><li class="chapter-item expanded "><a href="calibre_link-180.html"><strong aria-hidden="true">15.11.</strong> 长时处理过程的状态机和超时跟踪器 </a></li><li class="chapter-item expanded "><a href="calibre_link-181.html"><strong aria-hidden="true">15.12.</strong> 设计一个更复杂的长时处理过程 </a></li><li class="chapter-item expanded "><a href="calibre_link-182.html"><strong aria-hidden="true">15.13.</strong> 当消息机制或你的系统不可用时 </a></li><li class="chapter-item expanded "><a href="calibre_link-183.html"><strong aria-hidden="true">15.14.</strong> 本章小结 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-184.html"><strong aria-hidden="true">16.</strong> 第14章 应用程序 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calibre_link-185.html"><strong aria-hidden="true">16.1.</strong> 用户界面 </a></li><li class="chapter-item expanded "><a href="calibre_link-186.html"><strong aria-hidden="true">16.2.</strong> 渲染领域对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-187.html"><strong aria-hidden="true">16.3.</strong> 渲染数据传输对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-187.html"><strong aria-hidden="true">16.4.</strong> 使用调停者发布聚合的内部状态 </a></li><li class="chapter-item expanded "><a href="calibre_link-188.html"><strong aria-hidden="true">16.5.</strong> 通过领域负载对象渲染聚合实例 </a></li><li class="chapter-item expanded "><a href="calibre_link-189.html"><strong aria-hidden="true">16.6.</strong> 聚合实例的状态展现</a></li><li class="chapter-item expanded "><a href="calibre_link-190.html"><strong aria-hidden="true">16.7.</strong> 用例优化资源库查询 </a></li><li class="chapter-item expanded "><a href="calibre_link-190.html"><strong aria-hidden="true">16.8.</strong> 处理不同类型的客户端 </a></li><li class="chapter-item expanded "><a href="calibre_link-191.html"><strong aria-hidden="true">16.9.</strong> 渲染适配器以及处理用户编辑 </a></li><li class="chapter-item expanded "><a href="calibre_link-192.html"><strong aria-hidden="true">16.10.</strong> 应用服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-192.html"><strong aria-hidden="true">16.11.</strong> 示例应用服务 </a></li><li class="chapter-item expanded "><a href="calibre_link-193.html"><strong aria-hidden="true">16.12.</strong> 解耦服务输出 </a></li><li class="chapter-item expanded "><a href="calibre_link-194.html"><strong aria-hidden="true">16.13.</strong> 组合多个限界上下文 </a></li><li class="chapter-item expanded "><a href="calibre_link-195.html"><strong aria-hidden="true">16.14.</strong> 基础设施 </a></li><li class="chapter-item expanded "><a href="calibre_link-196.html"><strong aria-hidden="true">16.15.</strong> 企业组件容器 </a></li><li class="chapter-item expanded "><a href="calibre_link-197.html"><strong aria-hidden="true">16.16.</strong> 本章小结 </a></li><li class="chapter-item expanded "><a href="calibre_link-198.html"><strong aria-hidden="true">16.17.</strong> 附录A 聚合与事件源：A+ES </a></li><li class="chapter-item expanded "><a href="calibre_link-199.html"><strong aria-hidden="true">16.18.</strong> 应用服务内部 </a></li><li class="chapter-item expanded "><a href="calibre_link-200.html"><strong aria-hidden="true">16.19.</strong> 命令处理器 </a></li><li class="chapter-item expanded "><a href="calibre_link-201.html"><strong aria-hidden="true">16.20.</strong> Lambda语法</a></li><li class="chapter-item expanded "><a href="calibre_link-202.html"><strong aria-hidden="true">16.21.</strong> 并发控制 </a></li><li class="chapter-item expanded "><a href="calibre_link-203.html"><strong aria-hidden="true">16.22.</strong> A+ES所带来的结构自由性 </a></li><li class="chapter-item expanded "><a href="calibre_link-203.html"><strong aria-hidden="true">16.23.</strong> 性能 </a></li><li class="chapter-item expanded "><a href="calibre_link-204.html"><strong aria-hidden="true">16.24.</strong> 实现事件存储 </a></li><li class="chapter-item expanded "><a href="calibre_link-205.html"><strong aria-hidden="true">16.25.</strong> 关系型持久化 </a></li><li class="chapter-item expanded "><a href="calibre_link-206.html"><strong aria-hidden="true">16.26.</strong> BLOB持久化 </a></li><li class="chapter-item expanded "><a href="calibre_link-207.html"><strong aria-hidden="true">16.27.</strong> 专注的聚合 </a></li><li class="chapter-item expanded "><a href="calibre_link-208.html"><strong aria-hidden="true">16.28.</strong> 读模型投射 </a></li><li class="chapter-item expanded "><a href="calibre_link-209.html"><strong aria-hidden="true">16.29.</strong> 与聚合设计一道使用 </a></li><li class="chapter-item expanded "><a href="calibre_link-209.html"><strong aria-hidden="true">16.30.</strong> 增强事件 </a></li><li class="chapter-item expanded "><a href="calibre_link-210.html"><strong aria-hidden="true">16.31.</strong> 工具和模式 </a></li><li class="chapter-item expanded "><a href="calibre_link-211.html"><strong aria-hidden="true">16.32.</strong> 事件序列器 </a></li><li class="chapter-item expanded "><a href="calibre_link-212.html"><strong aria-hidden="true">16.33.</strong> 事件不变性 </a></li><li class="chapter-item expanded "><a href="calibre_link-212.html"><strong aria-hidden="true">16.34.</strong> 值对象 </a></li><li class="chapter-item expanded "><a href="calibre_link-213.html"><strong aria-hidden="true">16.35.</strong> 协议生成 </a></li><li class="chapter-item expanded "><a href="calibre_link-214.html"><strong aria-hidden="true">16.36.</strong> 单元测试和需求规范 </a></li><li class="chapter-item expanded "><a href="calibre_link-215.html"><strong aria-hidden="true">16.37.</strong> 事件源和函数式语言 </a></li></ol></li><li class="chapter-item expanded "><a href="calibre_link-216.html"><strong aria-hidden="true">17.</strong> 参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">实现领域驱动设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rest作为一种架构风格"><a class="header" href="#rest作为一种架构风格">REST作为一种架构风格</a></h1>
<div align = "center"><img src = "images/000000.jpg"/></div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="calibre_link-40.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="calibre_link-41.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="calibre_link-40.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="calibre_link-41.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
